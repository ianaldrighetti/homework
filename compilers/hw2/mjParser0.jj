// This is supporting software for CS321 Compilers and Language Design I
// Copyright (c) Portland State University
//
//----------------------------------------------------------------------
// miniJava F14 Raw Grammar (JavaCC Specification)
//
// (For CS321 Fall 2014 - Jingke Li)
//----------------------------------------------------------------------
//
//

// options { LOOKAHEAD=2; DEBUG_PARSER=true; }  /* Show debugging info */

PARSER_BEGIN(mjParser0)
import java.io.*;

public class mjParser0 {
  public static void main(String [] args) {
    try {
      if (args.length == 1) {
	FileInputStream stream = new FileInputStream(args[0]);
	new mjParser0(stream).Program();
	stream.close();
	System.out.println("Program's syntax is valid.");
      } else {
	System.out.println("Need a file name as command-line argument.");
      }
    } catch (TokenMgrError e) {
      System.err.println(e);
    } catch (Exception e) {
      System.err.println(e);
    }
  }
}
PARSER_END(mjParser0)

//
// LEXER SECTION ---------------------------------------------------------------
//

SKIP : /* White space */
{
  " " | "\t" | "\n" | "\r" | "\f"
}

SKIP : /* Comments -- multi-line form and error detection not included */
{
  <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
}

TOKEN : /* Keywords */
{
    "class" | "extends" | "static" | "public" | "void" | "int" | "boolean"
| "new" | "this" | "if" | "else" | "while" | "return" | "main" | "String" 
| "true" | "false" | "System" | "out" | "println" 
}

TOKEN : /* Internal tokens */
{
  <#DIGIT:  ["0"-"9"]>
| <#LETTER: (["A"-"Z"]|["a"-"z"])>
}

TOKEN : /* Integer literals -- error detection not included */
{
  <INTLIT: (<DIGIT>)+> 
}

TOKEN : /* String literals  -- error detection not included */
{
  <STRLIT: ("\"" (~["\"","\n"])* "\"")>
}

TOKEN : /* Identifiers */
{
  <ID: <LETTER> (<LETTER>|<DIGIT>)*>
}

TOKEN : /* Operators and delimiters */
{
   "+" | "-" | "*" | "/" | "&&" | "||" | "!" 
|  "==" | "!=" | "<" | "<=" | ">" | ">="
|  "=" | ";" | "," | "." | "(" | ")" | "[" | "]" | "{" | "}"
}

//
// PARSER SECTION ---------------------------------------------------------------
//

// Program -> {ClassDecl}
//
void Program(): {}
{
	(ClassDecl())* <EOF>
}

// ClassDecl -> "class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
//
void ClassDecl(): {}
{
	"class" <ID> ["extends" <ID>] "{" (VarDecl())* (MethodDecl())* "}"
}

// MethodDecl -> "public" MethodDecl'
// 
void MethodDecl(): {} 
{
	"public" MethodDeclP()
}

// MethodDecl' -> ExtType ID "(" [Param ["," Param]] ")" MethodBody
//	| "static" "void" "main" "(" "String" "[" "]" ID ")" MethodBody 
void MethodDeclP(): {}
{
	ExtType() <ID> "(" [Param() ("," Param())*] ")" "{" MethodBody() "}"
	| "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" MethodBody() "}"
}

// MethodBody -> "{" (VarDecl())* (Stmt())* "}"
void MethodBody(): {}
{	
    (Stmt())* // todo: vardecl
    //(VarDecl())* (Stmt())*// todo: stmt
//"B" //LOOKAHEAD(2)
	//"{" (VarDecl())* (Stmt())* "}"
}

// Param -> Type <ID> 
//
void Param(): {} 
{
	Type() <ID> 
}

void VarDecl(): {}
{
	[BasicType() ["[" "]"]] <ID> ["=" InitExpr()] ";"
}

void ExtType(): {}
{
	Type() | "void"
}

// todo: extid ( args), lvalue
void Stmt(): {}
{
    BlockStmt()
    //| Type() <ID> ["=" InitExpr()] ";"
    //| Lvalue() ["(" [Args()] ")"] ";"
    //| Lvalue() "=" InitExpr() ";"
    | "this" "." <ID> "=" InitExpr() ";"
    | <ID> [["."] <ID> | "[" <INTLIT> "]"] ["(" (Args())* ")" | "=" InitExpr()] ";"
    | [<ID> ["."] | BasicType() ["[" "]"]] <ID> ["[" <INTLIT> "]"] ["=" InitExpr()] ";"
    | "if" "(" Expr() ")" Stmt() [LOOKAHEAD(1) "else" Stmt()]
    | "while" "(" Expr() ")" Stmt()
    | "System" "." "out" "." "println" "(" [PrintArg()] ")" ";"
    | "return" [Expr()] ";"
}

void BlockStmt(): {}
{
	"{" (Stmt())* "}"
}

void PrintArg(): {}
{
    Expr() | <STRLIT>
}

void InitExpr(): {}
{
	"new" InitObjectExpr() | Expr()
}

void InitObjectExpr(): {}
{
	BasicType() "[" <INTLIT> "]" | <ID> "(" ")"
}
// todo: method call
void Expr(): {}
{
	P() (BinOp() P())*
}

void Args(): {}
{
	Expr() ("," Expr())*
}

void P(): {}
{
	Value() | "(" Expr() ")" | UnOp() P()
}

void Value(): {}
{
	Literal() | Lvalue() ["(" (Args())* ")"]
}

void Lvalue(): {}
{
	ExtId() //maybe OR this with VALUE's lvalue?
}

void ExtId(): {}
{
    ["this" "."] <ID> ("." <ID>)* ["[" Expr() "]"] // may need to move
	// this out to the proper calls (Lvalue including)
}

void Type(): {}
{
    <ID> | BasicType() ["[" "]"]
	//<ID> | BasicType() ["[" "]"]
}

void BasicType(): {}
{
	"int" | "boolean"
}

void Literal(): {}
{
	<INTLIT> | "true" | "false"
}

void BinOp(): {}
{
	"+" | "-" | "*" | "/" | "&&" | "||"
	| "==" | "!=" | "<" | "<=" | ">" | ">="
}

void UnOp(): {}
{
	"-" | "!"
}